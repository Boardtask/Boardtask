APP_NAME = boardtask

.PHONY: setup hosts dev caddy run build test migrate clean db-backup db-reset-wal db-reset squash-migrations

# Install required dev tools
setup:
	@echo "Installing sqlx-cli..."
	cargo install sqlx-cli --no-default-features --features sqlite
	@echo "Installing cargo-watch..."
	cargo install cargo-watch
	@echo ""
	@echo "âœ“ Dev tools installed!"
	@echo "Don't forget to install Caddy: brew install caddy"

# Add $(APP_NAME).local to /etc/hosts
hosts:
	@if grep -q "$(APP_NAME).local" /etc/hosts; then \
		echo "$(APP_NAME).local already in /etc/hosts"; \
	else \
		echo "Adding $(APP_NAME).local to /etc/hosts (requires sudo)"; \
		echo "127.0.0.1 $(APP_NAME).local" | sudo tee -a /etc/hosts; \
	fi

# Run in dev mode with auto-reload on file changes
dev:
	cargo watch -x run

# Run Caddy reverse proxy (run this in a separate terminal)
caddy:
	caddy run

# Run once (no auto-reload)
run:
	cargo run

# Build optimised release binary
build:
	cargo build --release

# Run all tests (warnings as errors)
test:
	RUSTFLAGS="-D warnings" cargo test

# Create the SQLite database and run all migrations
migrate:
	sqlx database create --database-url sqlite:$(APP_NAME).db
	sqlx migrate run --database-url sqlite:$(APP_NAME).db

# Run database seeds (uses DATABASE_URL from .env, default sqlite:boardtask.db)
seed:
	cargo run --bin seed

# Force re-run all seeds
seed-force:
	cargo run --bin seed -- --force-all

# Back up the database to a timestamped file using SQLite's .backup (safe, consistent snapshot).
# Do not use cp: it can corrupt the DB if WAL is in use or the file is being written.
db-backup:
	@if [ -f $(APP_NAME).db ]; then \
		backup="$(APP_NAME)_backup_$$(date +%Y%m%d_%H%M%S).db"; \
		sqlite3 $(APP_NAME).db ".backup \"$$backup\"" && echo "Backup written to $$backup"; \
	else \
		echo "No $(APP_NAME).db to back up."; \
	fi

# Clear SQLite WAL/shm files (fixes disk I/O error 522). Stop the app first.
db-reset-wal:
	rm -f $(APP_NAME).db-shm $(APP_NAME).db-wal
	@echo "WAL/shm cleared. Start the app again (e.g. make dev)."

# Squash all migrations into a single schema migration. Backs up the live DB (safe snapshot), then dumps schema from that backup.
squash-migrations:
	@test -f $(APP_NAME).db || { echo "No $(APP_NAME).db. Run make migrate first."; exit 1; }; \
	BACKUP="$(APP_NAME)_backup_$$(date +%Y%m%d_%H%M%S).db"; \
	echo "Backing up live DB to $$BACKUP..."; \
	sqlite3 $(APP_NAME).db ".backup \"$$BACKUP\"" && \
	VERSION=$$(date +%Y%m%d%H%M%S); \
	OUT="migrations/$${VERSION}_schema.sql"; \
	echo "Dumping schema from $$BACKUP..."; \
	echo "-- Squashed migration: full schema. Tables/indexes use IF NOT EXISTS." > "$$OUT"; \
	echo "-- Generated by: make squash-migrations" >> "$$OUT"; \
	echo "" >> "$$OUT"; \
	sqlite3 "$$BACKUP" ".schema" >> "$$OUT"; \
	echo "Adding IF NOT EXISTS and system task_statuses seed..."; \
	sed -e 's/^CREATE TABLE /CREATE TABLE IF NOT EXISTS /' \
	    -e 's/^CREATE INDEX /CREATE INDEX IF NOT EXISTS /' \
	    -e 's/^CREATE UNIQUE INDEX /CREATE UNIQUE INDEX IF NOT EXISTS /' \
	    "$$OUT" > "$$OUT.tmp" && mv "$$OUT.tmp" "$$OUT"; \
	printf '\nINSERT OR IGNORE INTO task_statuses (id, organization_id, name, sort_order, created_at) VALUES\n  ('"'"'01JSTATUS00000000TODO0000'"'"', NULL, '"'"'To do'"'"', 0, unixepoch()),\n  ('"'"'01JSTATUS00000000INPROG00'"'"', NULL, '"'"'In progress'"'"', 1, unixepoch()),\n  ('"'"'01JSTATUS00000000DONE0000'"'"', NULL, '"'"'Done'"'"', 2, unixepoch());\n' >> "$$OUT"; \
	echo "Created $$OUT"; \
	echo "Next: remove old migration files and keep only $$OUT, then run 'make migrate' on a fresh DB to verify."

# Remove corrupted/broken database so next run recreates it via migrations. Backs up first, then requires confirmation.
db-reset: db-backup
	@echo "This will DELETE $(APP_NAME).db and WAL/shm. All data will be lost. (A backup was just created.)"
	@printf "Type 'yes' to confirm: " && read confirm && [ "$$confirm" = "yes" ] || (echo "Aborted."; exit 1)
	rm -f $(APP_NAME).db $(APP_NAME).db-shm $(APP_NAME).db-wal
	@echo "Database removed. Next 'make dev' or 'make run' will create a fresh DB and run migrations."

# Remove build artifacts and the local database
clean:
	cargo clean
	rm -f $(APP_NAME).db $(APP_NAME).db-shm $(APP_NAME).db-wal
